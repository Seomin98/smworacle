--5. 부서별 급여 평균이 3,000,000원(버림적용) 이상인  부서들에 대해서 부서명, 급여평균을 출력하세요.
SELECT DEPT_CODE, FLOOR(AVG(SALARY))
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING FLOOR(AVG(SALARY)) >= 3000000;

-- # HAVING절
-- 그룹함수로 값을 구해온 그룹에 대해 조건을 설정할 때는
-- HAVING절에 기술함!! WHERE절은 사용 불가!!!!!!!!!!!!!!!!!!!!!!!!!!!

--@실습문제
--1. 부서별 인원이 5명보다 많은 부서와 인원수를 출력하세요.
SELECT DEPT_CODE, COUNT(*)
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING COUNT(*) > 5;

--2. 부서별 직급별 인원수가 3명이상인 직급의 부서코드, 직급코드, 인원수를 출력하세요.
SELECT DEPT_CODE, COUNT(*)
FROM EMPLOYEE
GROUP BY DEPT_CODE;
SELECT DEPT_CODE,JOB_CODE, COUNT(*)
FROM EMPLOYEE
GROUP BY DEPT_CODE, JOB_CODE
HAVING COUNT(*) >= 3
ORDER BY 1 ASC;

--3. 매니져가 관리하는 사원이 2명이상인 매니져아이디와 관리하는 사원수를 출력하세요.
SELECT MANAGER_ID, COUNT(*)
FROM EMPLOYEE
GROUP BY MANAGER_ID
HAVING COUNT(*) >= 2 AND MANAGER_ID IS NOT NULL
ORDER BY 1 ASC;

--# ROLLUP과 CUBE
SELECT JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY ROLLUP(JOB_CODE)
ORDER BY 1;

SELECT JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY CUBE(JOB_CODE)
ORDER BY 1;

-- 부서 내 직급별 급여 합계
SELECT DEPT_CODE, JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY ROLLUP(DEPT_CODE, JOB_CODE)
ORDER BY 1;

SELECT DEPT_CODE, JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY CUBE(DEPT_CODE, JOB_CODE)
ORDER BY 1;

-- 집합연산자
-- A = {1, 2, 4}, B = {2, 5, 7}
-- A∩B = { 2 }? 공통 값 -> 교집합
-- A∪B = {1, 2, 4, 5, 7}? -> 합집합
-- A-B = {1, 4}? -> 차집합
-- A - A∩B = {1, 4}
-- 교집합 -> INTERSECT
-- 합집합 -> UNION, UNION ALL
-- 차집합 -> MINUS
-- ResultSet 이 뭔가요?

-- 교집합 연산
SELECT EMP_NAME, EMP_ID FROM EMPLOYEE WHERE DEPT_CODE = 'D5'
INTERSECT
SELECT EMP_NAME, EMP_ID FROM EMPLOYEE WHERE SALARY >= 2400000;
-- 합집합1(중복 허용)
SELECT EMP_NAME, EMP_ID FROM EMPLOYEE WHERE DEPT_CODE = 'D5'
UNION ALL
SELECT EMP_NAME, EMP_ID FROM EMPLOYEE WHERE SALARY >= 2400000;
-- 합집합2(중복 제거)
SELECT EMP_NAME, EMP_ID FROM EMPLOYEE WHERE DEPT_CODE = 'D5'
UNION 
SELECT EMP_NAME, EMP_ID FROM EMPLOYEE WHERE SALARY >= 2400000;
-- 차집합
SELECT EMP_NAME, EMP_ID FROM EMPLOYEE WHERE DEPT_CODE = 'D5'
MINUS
SELECT EMP_NAME, EMP_ID FROM EMPLOYEE WHERE SALARY >= 2400000;

--** UNION의 조건!!
-- 1. SELECT문의 칼럼 갯수가 반드시 같아야 함
-- 2. 컬럼의 데이처 타입이 반드시 같거나 변환가능해야함 (ex. CHAR - VARCHAR2)
SELECT EMP_NAME, EMP_ID FROM EMPLOYEE WHERE DEPT_CODE = 'D5'
UNION
SELECT EMP_NAME, EMP_ID FROM EMPLOYEE WHERE SALARY >= 2400000;

-- 조인문(JOIN)
---- 여러 테이블의 레코드를 조합하여 하나의 열로 표현한 것
---> 두 개 이상의 테이블에서 연관성을 가지고 있는 데이터들을 컬럼 기준으로 분류하여
-- 새로운 가상의 테이블을 이용하여 출력함
-- 다시말해, 서로 다른 테이블에서 각각의 공통값을 이용함으로서 필드를 조합함.

--11. 사원명과, 부서명을 출력하세요.
--   부서코드가 D5이면 총무부, D6이면 기획부, D9이면 영업부로 처리하시오.(case 사용)
--   단, 부서코드가 D5, D6, D9 인 직원의 정보만 조회하고, 부서코드 기준으로 오름차순 정렬함.
SELECT EMP_NAME, DECODE(DEPT_CODE, 'D9', '총무부', 'D5', '해외영업1부', 'D6', '해외영업2부')
FROM EMPLOYEE
WHERE DEPT_CODE IN ('D5', 'D6', 'D9');
SELECT * FROM DEPARTMENT;

SELECT EMP_NAME, DEPT_CODE FROM EMPLOYEE;
SELECT DEPT_ID DEPT_TITLE FROM DEPARTMENT;

-- # 조인문
-- SELECT 컬럼명 FROM 테이블 JOIN 테이블 ON 컬럼명1 = 컬럼명2
SELECT EMP_NAME, DEPT_TITLE 
FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID;
-- ANSI 표준구문
SELECT EMP_NAME, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT WHERE DEPT_CODE = DEPT_ID;
-- 오라클 전용 구문
-- JOIN의 종류1
-- 1. EQUI-JOIN : 일반적으로 사용, =에 의한 조인
-- 2. NON-Equi JOIN : 동등조건이 아닌 BETWEEN AND, IS NULL, IS NOT NULL, IN, NOT IN 등으로 사용

-- @실습문제
--1. 부서명과 지역명을 출력하세요. DEPARTMENT, LOCATION 테이블 이용.
SELECT DEPT_TITLE, LOCAL_NAME FROM DEPARTMENT JOIN LOCATION ON LOCATION_ID = LOCAL_CODE;

SELECT * FROM LOCATION;

--2. 사원명과 직급명을 출력하세요. EMPLOYEE, JOB 테이블 이용
-- 모호한 것을 해결방법
SELECT EMP_NAME, JOB_NAME FROM EMPLOYEE JOIN JOB
ON EMPLOYEE.JOB_CODE = JOB.JOB_CODE;
SELECT * FROM JOB;
-- 모호한 것을 해결방법2
SELECT EMP_NAME, JOB_NAME FROM EMPLOYEE EMP JOIN JOB JB
ON EMP.JOB_CODE = JB.JOB_CODE;
-- 모호한 것을 해결방법3
SELECT EMP_NAME, JOB_NAME FROM EMPLOYEE JOIN JOB 
USING(JOB_CODE);

SELECT * FROM JOB;
--3. 지역명과 국기명을 출력하세요. LOCATION, NATIONAL 테이블 이용
SELECT * FROM LOCATION, NATIONAL;
SELECT * FROM NATIONAL;
SELECT LOCAL_NAME, NATIONAL_NAME 
FROM LOCATION JOIN NATIONAL
USING(NATIONAL_CODE);

SELECT LOCAL_NAME, NATIONAL_NAME FROM NATIONAL
JOIN LOCATION USING(NATIONAL_CODE);

-- ## INNRT JOIN
-- ## INNER EQUI JOIN

-- ## JOIN의 종류2
-- INNER JOIN(내부조인) : 일반적으로 사용하는 조인(교집합)
-- OUTER IN(외부조인) : 합집합, 모두 출력
-- -> 1. LEFT (OUTER) JOIN
-- -> 1. RIGHT (OUTER) JOIN
-- -> 1. FULL (OUTER) JOIN
SELECT EMP_NAME, DEPT_TITLE
FROM EMPLOYEE INNER JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID;

-- ANSI 표준 구문
SELECT EMP_NAME, DEPT_TITLE
FROM EMPLOYEE LEFT JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID;

-- 오라클 전용 구문
SELECT EMP_NAME, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT WHERE DEPT_CODE = DEPT_ID(+);

-- ANSI 표준 구문
SELECT EMP_NAME, DEPT_TITLE
FROM EMPLOYEE RIGHT JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID;

-- 오라클 전용 구문
SELECT EMP_NAME, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT ON DEPT_CODE(+)= DEPT_ID;

-- ANSI 표준 구문만 존재
SELECT EMP_NAME, DEPT_TITLE
FROM EMPLOYEE FULL JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID;

-- OUTER JOIN(외부 조인)을 살펴보자
SELECT EMP_NAME, DEPT_TITLE
FROM EMPLOYEE LEFT JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID;

SELECT EMP_NAME, DEPT_TITLE
FROM DEPARTMENT RIGHT JOIN EMPLOYEE ON DEPT_ID = DEPT_CODE;

-- ## JOIN의 종류3
-- 1. 상호조인(CROSS JOIN)
-- 2. 셀프조인(SELF JOIN)
-- 3. 다중조인
-- -> 여러 개의 조인문을 한번에 사용할 수 있음
SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE
JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID
JOIN LOCATION ON LOCATION_ID = LOCAL_CODE;
---> 순서가 중요하다!!

--@실습문제
-- 1. 직급이 대리이면서, ASIA 지역에 근무하는 직원 조회
-- 사번, 이름 ,직급명, 부서명, 근무지역명, 급여를 조회하시오
SELECT EMP_ID AS 사번, EMP_NAME AS 이름, JOB_NAME AS 직급명,  DEPT_TITLE AS 부서명
, LOCAL_NAME AS 근무지역명, SALARY AS 급여
FROM EMPLOYEE;
JOIN JOB USING(JOB_CODE)
JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID
JOIN LOCATION ON LOCATION_ID = LOCAL_CODE
-- WHERE JOB_NAME = '대리' AND LOCAL_NAME IN ('ASIA1','ASIA2','ASIA3')
WHERE JOB_NAME = '대리' AND LOCAL_NAME LIKE 'ASIA%';

SELECT * FROM EMPLOYEE, DEPARTMENT;








